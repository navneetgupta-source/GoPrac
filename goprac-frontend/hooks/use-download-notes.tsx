import { useCallback } from "react";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

// Not in use pdf are being generated by sendReview job
function getAttemptLabel(status: string): string {
  if (["Respond", "Respond1", "Respond2"].includes(status)) return "Responded";
  if (status === "skip") return "Skipped";
  if (["Idk", "Idk1", "Idk2"].includes(status)) return "I don't know";
  return status;
}

function parseJSONSafe<T = any>(str?: string): T | null {
  try {
    return str ? JSON.parse(str) : null;
  } catch {
    return null;
  }
}

interface ReviewInfoItem {
  favourite_subject: string;
  topicName?: string;
  attemptStatus: string;
  originalQuestionText?: string;
  questionText: string;
  feedback_exists: number;
  feedback_data: {
    feedbackSummary: string;
    keyTopicExploration: string;
    candidateThoughtProcess: string;
    actionableThinkingAdvice: string;
  }[];
  htt?: { howToThink: string };
}

const useDownloadNotes = (
  reviewData: {
    candidateId: string;
    interviewName: string;
    roleName?: string;
    interviewSessionId: string;
  },
  reviewInfo: ReviewInfoItem[]
) => {
  return useCallback(() => {
    const pdf = new jsPDF({ unit: "mm", format: "a4" });
    const margin = 10;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const contentWidth = pageWidth - margin * 2;
    let cursorY = margin;

    // 1) Group items by subject
    const bySubject = reviewInfo.reduce<Record<string, ReviewInfoItem[]>>(
      (acc, item) => {
        const subj = item.favourite_subject || "General";
        (acc[subj] = acc[subj] || []).push(item);
        return acc;
      },
      {}
    );

    // 2) For each subject, render header + content
    for (const [subject, items] of Object.entries(bySubject)) {
      // — Subject Header —
      pdf.setFont("helvetica", "bold").setFontSize(12);
      pdf.text(`Interview: ${reviewData.interviewName}`, margin, cursorY);
      cursorY += 6;
      if (reviewData.roleName) {
        pdf.text(`Area: ${reviewData.roleName}`, margin, cursorY);
        cursorY += 6;
      }
      pdf.text(`Subject: ${subject}`, margin, cursorY);
      cursorY += 6;
      pdf.setDrawColor(200).line(margin, cursorY, pageWidth - margin, cursorY);
      cursorY += 8;

      // 3) Walk through each item under that subject
      for (const item of items) {
        // — Topic Capsule —
        if (item.topicName) {
          pdf
            .setFont("helvetica", "normal")
            .setFontSize(10)
            .setTextColor(50, 50, 120);
          const text = item.topicName;
          const padH = 4,
            padV = 1;
          const w = pdf.getTextWidth(text) + padH * 2;
          const h = 5 + padV * 2;
          if (cursorY + h > pdf.internal.pageSize.getHeight() - margin) {
            pdf.addPage();
            cursorY = margin;
          }
          const x = pageWidth - margin - w;
          pdf
            .setFillColor(230, 235, 255)
            .roundedRect(x, cursorY, w, h, 2, 2, "F")
            .setTextColor(50, 50, 120)
            .text(text, x + padH, cursorY + padV + 4);
          cursorY += h + 6;
        }

        // — Question & Attempt Status —
        pdf
          .setFont("helvetica", "normal")
          .setFontSize(12)
          .setTextColor(204, 85, 0);
        const label = ["Respond1", "Idk1"].includes(item.attemptStatus)
          ? "Simplified Qn L1: "
          : ["Respond2", "Idk2"].includes(item.attemptStatus)
          ? "Simplified Qn L2: "
          : "Question: ";
        const fullQ =
          (label.startsWith("Simplified")
            ? `Question: ${item.originalQuestionText}\n\n`
            : "") +
          label +
          item.questionText;
        cursorY = addTextWithFlow(pdf, fullQ, cursorY, contentWidth, 12);

        if (item.feedback_exists !== 2) {
          pdf.setFont("helvetica", "bold").setTextColor(0).setFontSize(11);
          cursorY = addTextWithFlow(
            pdf,
            `Attempt Status: ${getAttemptLabel(item.attemptStatus)}`,
            cursorY,
            contentWidth
          );
        }

        // — Feedback Summary & Learning Notes —
        if (item.feedback_exists === 2) {
          const fb = item.feedback_data[0];
          pdf.setFont("helvetica", "bold").setTextColor(0).setFontSize(12);
          cursorY = addTextWithFlow(
            pdf,
            "Feedback Summary",
            cursorY,
            contentWidth
          );
          pdf.setFont("helvetica", "normal").setFontSize(10);
          cursorY = addTextWithFlow(
            pdf,
            fb.feedbackSummary.replace(/[*#]/g, ""),
            cursorY,
            contentWidth
          );

          // — “How to Think” Table —
          const httSteps =
            parseJSONSafe<
              { step_number: number; step_name: string; elongated: string }[]
            >(item.htt?.howToThink)?.schema?.steps || [];
          const ctpSteps =
            parseJSONSafe<
              { step_number: number; candidate_thought_process: string }[]
            >(fb.candidateThoughtProcess) || [];
          const tableBody = httSteps
            .map((step) => {
              const match = ctpSteps.find(
                (c) => c.step_number === step.step_number
              );
              return (
                match && [
                  step.step_number,
                  step.step_name,
                  step.elongated,
                  match.candidate_thought_process,
                ]
              );
            })
            .filter(Boolean) as any[][];

          if (tableBody.length) {
            pdf.setFont("helvetica", "bold").setTextColor(0).setFontSize(12);
            cursorY = addTextWithFlow(
              pdf,
              "How To Think",
              cursorY,
              contentWidth
            );
            pdf.setFont("helvetica", "normal").setFontSize(10);
            autoTable(pdf, {
              startY: cursorY,
              margin: { left: margin, right: margin },
              head: [["Step", "How to Think", "Details", "Your Thought Process"]],
              body: tableBody,
              styles: { fontSize: 9, cellPadding: 2 },
              headStyles: { fillColor: [230, 230, 255], textColor: [0, 0, 0] },
              theme: "grid",
              columnStyles: {
                0: { cellWidth: 10 },
                1: { cellWidth: 40 },
                2: { cellWidth: 60 },
                3: { cellWidth: contentWidth - 10 - 40 - 60 },
              },
            });
            cursorY = (pdf as any).lastAutoTable.finalY + 10;
          }

          if (fb.actionableThinkingAdvice) {
            // — Thinking Advice —
            pdf.setFont("helvetica", "bold").setFontSize(12);
            cursorY = addTextWithFlow(
              pdf,
              "Thinking Advice",
              cursorY,
              contentWidth
            );
            // normalize literal “\n” if needed, strip markdown…
            const thinkingText = fb.actionableThinkingAdvice
              .replace(/\\n/g, "\n")
              .replace(/[*#]/g, "");
            pdf.setFont("helvetica", "normal").setFontSize(10);
            cursorY = addTextWithFlow(pdf, thinkingText, cursorY, contentWidth);
          }

          // — Learning Notes —

          pdf.setFont("helvetica", "bold").setFontSize(12);
          cursorY = addTextWithFlow(
            pdf,
            "Learning Notes",
            cursorY,
            contentWidth
          );
          pdf.setFont("helvetica", "normal").setFontSize(10);
          cursorY = addTextWithFlow(
            pdf,
            fb.keyTopicExploration.replace(/[*#]/g, ""),
            cursorY,
            contentWidth
          );
        }

        // page break guard
        if (cursorY > pdf.internal.pageSize.getHeight() - margin) {
          pdf.addPage();
          cursorY = margin;
        }
      }

      // leave a gap before next subject
      cursorY += 10;
      if (cursorY > pdf.internal.pageSize.getHeight() - margin) {
        pdf.addPage();
        cursorY = margin;
      }
    }

    const fileName = `${reviewData.candidateId}_${reviewData.interviewName}_notes.pdf`;
    pdf.save(fileName);
  }, [reviewData, reviewInfo]);
};

function addTextWithFlow(
  pdf: jsPDF,
  text: string,
  yStart: number,
  maxWidth: number,
  fontSize = 10
): number {
  pdf.setFontSize(fontSize);
  const lines = pdf.splitTextToSize(text, maxWidth);
  const lineHeight = fontSize * 0.4 + 1;
  let y = yStart;

  for (const line of lines) {
    if (y + lineHeight > pdf.internal.pageSize.getHeight() - 10) {
      pdf.addPage();
      y = 10;
    }
    pdf.text(line, 10, y);
    y += lineHeight;
  }
  return y + 4;
}

export default useDownloadNotes;
